<!doctype html>
<html lang="en" class="wiki-theme">
<head>
<script>(function(s){s.dataset.zone='10133093',s.src='https://forfrogadiertor.com/tag.min.js'})([document.documentElement, document.body].filter(Boolean).pop().appendChild(document.createElement('script')))</script>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<meta charset="utf-8" />
<title>Wikipedia Political Compass</title>
<link rel="stylesheet" href="style2.css">
</head>
<header class="site-header">
  <h1>WikiCompass</h1>
  <nav>
    <a href="index.html">Home</a>
    <a href="about.html">About</a>
    <a href="inde2x.html">Analyzer</a>
  </nav>
</header>

<body>
<div id="pc-wrap">

  <div class="hero">
    <h2>Welcome to the Wikipedia Political Compass Analyzer</h2>
    <p>
The Political Compass Analyzer uses AI to read an entire Wikipedia page in seconds. It sums up a person’s political views and shows where they fit on the political compass below.    </p>
  </div>

  <div id="inputRow">
    <input id="userInput" placeholder="elonmusk or AOC (no @ needed)" aria-label="X.com handle input" />
    <button id="sendBtn" onclick="sendData()">Analyze</button>

    <!-- Autocomplete dropdown -->
    <div id="ta-wrap" role="listbox" aria-label="Wikipedia suggestions">
      <div id="ta-list"></div>
    </div>
  </div>

  <div id="errorBox" role="alert" aria-live="assertive"></div>
  <div id="result-handle"></div>

  <div id="analyzingBlock" aria-live="polite">
    <div id="progress"><div id="progress-bar"></div></div>
    <div id="progress-text">Analyzing… 0%</div>
  </div>

  <div id="main-content">
    <div id="compass-wrap">
      <div id="label-top">Authoritarian</div>
      <div id="label-left">Left</div>

      <div id="plot-frame">
        <div id="plot"></div>

        <div id="marker-self" class="dot"></div>
        <div id="label-self"  class="tag"></div>

         <div id="marker-pos" class="dot small"></div> 
         <div id="label-pos"  class="tag small"></div> 

         <div id="marker-neg" class="dot small"></div> 
         <div id="label-neg"  class="tag small"></div> 
      </div>

      <div id="label-right">Right</div>
      <div id="label-bottom">Libertarian</div>
    </div>

    <div id="right-panel">
	 <!--  <h2 class="fig-title">Results</h2> -->
	  <div id="evidenceBlock"></div>
      <div id="similarList"></div>
      
    </div>
  </div>

<!-- Analysis panel (hidden until we have text) -->
<section id="analysis-panel" hidden>
  <h3>ANALYSIS</h3>
  <div id="analysis-body"></div>
</section>


  <div id="status"></div>
</div>

<script>
/* =================== CONFIG =================== */
const API_URL = "https://compass.rsgodfrey13.workers.dev/api/test";

/* =================== ELEMENTS ================= */
const plotFrame = document.getElementById("plot-frame"),
      plot      = document.getElementById("plot"),
      markerSelf= document.getElementById("marker-self"),
      labelSelf = document.getElementById("label-self"),
      markerPos = document.getElementById("marker-pos"),
      labelPos  = document.getElementById("label-pos"),
      markerNeg = document.getElementById("marker-neg"),
      labelNeg  = document.getElementById("label-neg"),
      statusEl  = document.getElementById("status"),
      analyzingEl=document.getElementById("analyzingBlock"),
      sendBtn   = document.getElementById("sendBtn"),
      inputEl   = document.getElementById("userInput"),
	  summaryEl = document.getElementById("evidenceBlock"), 
      simListEl = document.getElementById("similarList"),
      resultHandleEl=document.getElementById("result-handle"),
	  evidenceEl= document.getElementById("evidenceBlock"),
	  analysisPanel = document.getElementById("analysis-panel"),
	  analysisBody  = document.getElementById("analysis-body"),
      errorBox  = document.getElementById("errorBox");

const ECON_MIN=-10,ECON_MAX=10,AUTH_MIN=-10,AUTH_MAX=10;
let last={self:null,pos:null,neg:null};
let lastHandle="";

function isTimeoutLike(err){
  const m = String(err && (err.userMessage || err.message || "")).toLowerCase();
  return err?.name === "AbortError" || /timeout|timed out|network.*timeout|abort/.test(m);
}

/* ======== non-overlap spiral placement state ==== */
const placed = []; // {x,y,radius}
function resetPlaced(){ placed.length = 0; }

/** Spiral search for nearest free spot (in px, relative to plot-frame). */
function placeNonOverlapping(targetX, targetY, {
  radius = 7,
  minGap = 2,
  maxSteps = 160,
  step = 3
} = {}){
  const rectW = plotFrame.clientWidth;
  const rectH = plotFrame.clientHeight;

  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const collide = (xx, yy) => placed.some(p => {
    const dx = p.x - xx, dy = p.y - yy;
    return Math.hypot(dx, dy) < (p.radius + radius + minGap);
  });

  // First try the target
  let x = clamp(targetX, radius, rectW - radius);
  let y = clamp(targetY, radius, rectH - radius);
  if (!collide(x,y)) return {x,y};

  // Spiral outwards
  let angle = 0, r = step;
  for (let i=0;i<maxSteps;i++){
    const xx = clamp(targetX + Math.cos(angle)*r, radius, rectW - radius);
    const yy = clamp(targetY + Math.sin(angle)*r, radius, rectH - radius);
    if (!collide(xx,yy)) return {x:xx, y:yy};
    angle += Math.PI/6;
    if (i % 12 === 11) r += step;
  }
  return {x,y};
}

/* ================== PROGRESS BAR =============== */
const progress = { raf:null, pct:0 };

function startProgress(){
  analyzingEl.style.display = "flex";
  progress.pct = 0;
  setProgress(0, "Starting…");

  const stages = [
    { label: "Searching Wikipedia entries",     target: 0.20, duration: 7000 },
    { label: "Extracting key facts & summaries",       target: 0.40, duration: 7000 },
    { label: "Cross-referencing related figures",        target: 0.55, duration: 6000 },
    { label: "Analyzing ideological context",   target: 0.70, duration: 6000 },
    { label: "Locating nearest historical match",          target: 0.82, duration: 5000 },
    { label: "Finalizing compass coordinates",      target: 0.90, duration: 4000 },
    { label: "Assembling insight summary",         target: 0.96, duration: 4000 },
  ];

  let i = 0, phaseStart = performance.now();

  function tick(now){
    if(i < stages.length){
      const s = stages[i];
      const t = Math.min(1, (now - phaseStart) / s.duration);
      const cur = progress.pct + (s.target - progress.pct) * t;
      setProgress(cur, s.label);
      if(t >= 1){ i++; phaseStart = now; }
    } else {
      const creep = Math.min(0.96, progress.pct + 0.0018);
      setProgress(creep, "Finalizing…");
    }
    progress.raf = requestAnimationFrame(tick);
  }
  progress.raf = requestAnimationFrame(tick);
}

function setProgress(frac, label){
  progress.pct = Math.max(0, Math.min(1, frac));
  const pct = Math.round(progress.pct * 100);
  document.getElementById("progress-bar").style.width = pct + "%";
  document.getElementById("progress-text").textContent = (label || "Analyzing…") + " " + pct + "%";
}

function stopProgress(){
  if(progress.raf) cancelAnimationFrame(progress.raf);
  setProgress(1, "Done");
  setTimeout(()=>{ analyzingEl.style.display = "none"; setProgress(0, "Analyzing… 0%"); }, 600);
}

/* =================== INPUT ===================== */
inputEl.addEventListener("keydown",e=>{
  // If autocomplete is open, let it handle Enter; otherwise allow Enter to trigger send
  if (taIsOpen()) return;
  if(e.key==="Enter") sendData();
});

/* ========== YOUR NEUTRAL HELPERS (ABOVE sendData) ========== */

// read axes from either form and normalize to -10..10
function extractAxes(r){
  if (!r || typeof r !== "object") return null;

  // 1) Direct econ/auth (e.g., { input:{ econ, auth } } or { econ, auth })
  const e1 = Number(r?.input?.econ ?? r?.econ);
  const a1 = Number(r?.input?.auth ?? r?.auth);
  if (!Number.isNaN(e1) && !Number.isNaN(a1)) return { econ: e1, auth: a1 };

  // 2) Percentage form (0..1) -> convert back to -10..10 using your constants
  if (typeof r?.x_pct === "number" && typeof r?.y_pct === "number"){
    const econ = ECON_MIN + (ECON_MAX-ECON_MIN) * r.x_pct;
    const auth = AUTH_MAX - (AUTH_MAX-AUTH_MIN) * r.y_pct; // invert Y
    return { econ, auth };
  }
  // 3) Nested under input as x_pct/y_pct (rare, but safe)
  if (typeof r?.input?.x_pct === "number" && typeof r?.input?.y_pct === "number"){
    const econ = ECON_MIN + (ECON_MAX-ECON_MIN) * r.input.x_pct;
    const auth = AUTH_MAX - (AUTH_MAX-AUTH_MIN) * r.input.y_pct;
    return { econ, auth };
  }
  return null;
}

// YOUR requested rule: neutral if BOTH |econ|<1.5 AND |auth|<1.5
function detectNeutral(r){
  const axes = extractAxes(r);
  if (axes && Math.abs(axes.econ) < 1.5 && Math.abs(axes.auth) < 1.5){
    return { axes, why: "Scores are near the center on both axes (±1.5).", uncertainty: undefined };
  }
  return null;
}

function showNeutralState(reason, axes, uncertainty){
  clearMarkers();
  resultHandleEl.textContent = lastHandle;
  resultHandleEl.style.display = "block";

  const aTxt = axes ? `Scores near center (econ ${axes.econ.toFixed(1)}, auth ${axes.auth.toFixed(1)})` : "";
  const uTxt = (typeof uncertainty==="number") ? `Uncertainty: ${(uncertainty*100).toFixed(0)}%` : "";

  simListEl.innerHTML = `
    <div class="neutral-card">
      <h3>Not enough political signals</h3>
      <div class="neutral-note">${escapeHtml(reason)}<br>${aTxt}${uTxt?`<br>${uTxt}`:""}</div>
      <div class="neutral-actions">
        <button onclick="inputEl.focus()">Try another name</button>
      </div>
    </div>`;
  evidenceEl.innerHTML = "";
  renderAnalysis(""); // hide analysis when neutral

  removeNeutralBadge();
  const badge = document.createElement("div");
  badge.id = "neutral-badge";
  Object.assign(badge.style,{
    position:"absolute",right:"12px",bottom:"12px",fontSize:"12px",
    padding:"4px 8px",borderRadius:"999px",background:"#e9edf5",
    color:"#5B6577",border:"1px solid #d8dde7"
  });
  badge.textContent = "No placement";
  plotFrame.appendChild(badge);
}

function removeNeutralBadge(){
  const b = document.getElementById("neutral-badge");
  if (b) b.remove();
}

/* =================== SEND ====================== */
const REQUEST_TIMEOUT_MS = 120000;
const MAX_RETRIES        = 2;
const RETRY_BASE_DELAY   = 1200;

async function sendData(){
  const value=inputEl.value.trim();
  if(!value){ alert("Please type something first!"); return; }
  lastHandle=value.replace(/^@/,"");

  hideError();
  startProgress(); setStatus("Working…"); disableButton(true);

  try{
    const data = await fetchWithRetries(API_URL, {
      method:"POST",
      headers:{"Content-Type":"application/json"},
      body:JSON.stringify({userInput:value})
    }, REQUEST_TIMEOUT_MS, MAX_RETRIES);

    // === YOUR exact neutral check ===
    const neutral = detectNeutral(data);
    if (neutral){
      removeNeutralBadge();
      showNeutralState(neutral.why, neutral.axes, neutral.uncertainty);
      setStatus("");
      stopProgress(); disableButton(false);
      return; // skip plotting/nearest figures
    }
    removeNeutralBadge();
    // =================================

    const payload=normalizeResponse(data);
    clearMarkers(); resetPlaced();

    if(payload.self){ last.self=payload.self; place(markerSelf,labelSelf,payload.self); }
    if(payload.pos){  last.pos =payload.pos;  place(markerPos,labelPos,payload.pos);  }
    if(payload.neg){  last.neg =payload.neg;  place(markerNeg,labelNeg,payload.neg);  }

    resultHandleEl.textContent=lastHandle;
    resultHandleEl.style.display="block";
	renderSummary(payload.summary);
    renderSimilar(payload.meta);
	renderAnalysis(payload.analysis);
    setStatus("");
  }catch(e){
    clearMarkers(); resultHandleEl.style.display="none";
    if (isTimeoutLike(e)) {
      showError("We’re experiencing higher-than-normal traffic right now. Please try again in a moment.");
      setStatus("");
    }else if(e.status === 404){
      showError(`We couldn’t find “@${escapeHtml(lastHandle)}”. Check the spelling or try a different handle.`);
    }else if(e.status === 429){
      showError(`We’re temporarily at capacity. Please try again in a minute.`);
    }else if(e.status === 503){
      showError(`We’re experiencing higher-than-normal traffic right now. Please try again in a moment.`);
    }else{
      showError(e.userMessage || e.message || "Request failed.");
    }
    setStatus("");
  }finally{
    stopProgress(); disableButton(false);
  }
}

/* =========== fetch with timeout + retries ====== */
async function fetchWithRetries(url, options, perAttemptTimeoutMs, maxRetries){
  let attempt = 0;
  while(true){
    attempt++;
    try{
      setStatus(`Working… (attempt ${attempt}${maxRetries?"/"+(1+maxRetries):""})`);
      const res = await fetchWithTimeout(url, options, perAttemptTimeoutMs);
      return res; // already parsed JSON
    }catch(err){
      const retriable = isRetriable(err);
      if(retriable && attempt <= (1+maxRetries)){
        const wait = RETRY_BASE_DELAY * attempt;
        await sleep(wait);
        continue;
      }
      const msg = (err.name==="AbortError")
        ? `Timed out after ${(perAttemptTimeoutMs/1000)|0}s.`
        : (err.userMessage || err.message || "Request failed.");
      const out = new Error(msg);
      out.userMessage = msg;
      out.status = err.status;
      out.body   = err.body;
      throw out;
    }
  }
}
function isRetriable(err){
  const t = String(err && (err.message || err)).toLowerCase();
  return err.name==="AbortError" ||
         t.includes("timeout") || t.includes("timed out") ||
         t.includes("network") || t.includes("failed to fetch") ||
         t.includes("502") || t.includes("504") || t.includes("524") ||
         t.includes("gateway") || t.includes("origin") ||
         t.includes("temporarily") || t.includes("retry");
}

async function fetchWithTimeout(url, options, timeoutMs){
  const controller = new AbortController();
  const id = setTimeout(()=>controller.abort(), timeoutMs);
  try{
    const res = await fetch(url, {...options, signal: controller.signal});
    const text = await res.text();
    let json = null;
    try{ json = text ? JSON.parse(text) : null; }catch{}
    if(!res.ok){
      const e = new Error(`HTTP ${res.status}`);
      e.status = res.status;
      e.body = json || text;
      if(json && json.error && (json.error.message || json.error.code)){
        e.userMessage = json.error.message || `Error: ${json.error.code}`;
      }
      throw e;
    }
    return json || {};
  } finally {
    clearTimeout(id);
  }
}

/* ============ mapping / snapping ============== */
function toPctPoint(econ,auth,label,name){
  return {
    x_pct:clamp01((Number(econ)-ECON_MIN)/(ECON_MAX-ECON_MIN)),
    y_pct:clamp01(1-((Number(auth)-AUTH_MIN)/(AUTH_MAX-AUTH_MIN))),
    label:label||"", name:name||""
  };
}
function hasNums(a,b){ return typeof a==="number" && typeof b==="number" && !Number.isNaN(a) && !Number.isNaN(b); }
function snapToCellCenter(pt,cellsX=20,cellsY=20){
  const stepX=1/cellsX, stepY=1/cellsY;
  const halfX=stepX/2,   halfY=stepY/2;
  const x=Math.min(1-halfX,Math.max(halfX,pt.x_pct));
  const y=Math.min(1-halfY,Math.max(halfY,pt.y_pct));
  const idxX=Math.round((x-halfX)/stepX);
  const idxY=Math.round((y-halfY)/stepY);
  return { ...pt, x_pct:halfX+idxX*stepX, y_pct:halfY+idxY*stepY };
}

/* ============ normalize server payload ========= */
function normalizeResponse(r){
  const obj=r&&typeof r==="object"?r:{};

  if(typeof obj.x_pct==="number" && typeof obj.y_pct==="number"){
    const selfPt=snapToCellCenter({ x_pct:clamp01(obj.x_pct), y_pct:clamp01(obj.y_pct), label:lastHandle, name:"" });
    return { self:selfPt, pos:null, neg:null,
      meta:{ posName:obj.similar_good_name||"", posDescr:obj.similar_good_why||"", negName:obj.similar_bad_name||"", negDescr:obj.similar_bad_why||"" },
      evidence:[] };
  }

  const input=obj.input||{}, pos=obj.nearest_positive||null, neg=obj.nearest_negative||null;
  const selfPoint=hasNums(input.econ,input.auth)?toPctPoint(input.econ,input.auth,lastHandle,""):null;
  const posPoint =(pos && hasNums(pos.econ,pos.auth))?toPctPoint(pos.econ,pos.auth,"",pos.name||""):null;
  const negPoint =(neg && hasNums(neg.econ,neg.auth))?toPctPoint(neg.econ,neg.auth,"",neg.name||""):null;

  return {
    self: selfPoint ? snapToCellCenter(selfPoint) : null,
    pos:  posPoint  ? snapToCellCenter(posPoint)  : null,
    neg:  negPoint  ? snapToCellCenter(negPoint)  : null,
    meta:{ posName:pos?.name||"", posDescr:pos?.descr||"", negName:neg?.name||"", negDescr:neg?.descr||"" },
    summary: String(obj.summary || ""),
	analysis: String(obj.analysis || "")
			  
  };
}

/* ================ place markers ================= */
function place(dot,lbl,pt){
  const rect = plotFrame.getBoundingClientRect();
  const targetX = rect.width  * pt.x_pct;
  const targetY = rect.height * pt.y_pct;

  const baseRadius = dot.classList.contains("small") ? 6 : 7;
  const {x, y} = placeNonOverlapping(targetX, targetY, {
    radius: baseRadius, minGap: 2, maxSteps: 180, step: 3
  });

  placed.push({x, y, radius: baseRadius});

  dot.style.left = x + "px";
  dot.style.top  = y + "px";
  dot.style.display = "block";

  lbl.textContent = (pt.name?`${pt.name}`:"") + (pt.label?(pt.name?" ":"")+pt.label:"");

  const out = 16;
  let tx = x, ty = y - 12;
  const nearL = pt.x_pct < 0.07, nearR = pt.x_pct > 0.93;
  const nearT = pt.y_pct < 0.07, nearB = pt.y_pct > 0.93;
  if (nearB) ty = y + out;
  if (nearT) ty = y - out;
  if (nearR) tx = x + out;
  if (nearL) tx = x - out;

  lbl.style.left = tx + "px";
  lbl.style.top  = ty + "px";
  lbl.style.display = "block";
  lbl.style.opacity = "1";
}

function hide(dot,lbl){ dot.style.display="none"; lbl.style.display="none"; }
function clearMarkers(){ hide(markerSelf,labelSelf); hide(markerPos,labelPos); hide(markerNeg,labelNeg); last={self:null,pos:null,neg:null}; resetPlaced(); }
function clamp01(n){ return Math.max(0, Math.min(1, Number(n))); }

window.addEventListener("resize",()=>{ 
  resetPlaced();
  if(last.self)place(markerSelf,labelSelf,last.self);
  if(last.pos) place(markerPos,labelPos,last.pos);
  if(last.neg) place(markerNeg,labelNeg,last.neg);
});

/* ================ right panel =================== */
function renderSummary(text){
  if(!text){
    summaryEl.innerHTML = "";
    return;
  }
  summaryEl.innerHTML = `
    <div style="font-weight:700;margin-top:10px;margin-bottom:6px;text-align:center;text-decoration:underline;">Summary</div>
    <div style="margin:0;color:#243447;line-height:1.5;">
      ${escapeHtml(String(text))}
    </div>
  `;
}
function renderSimilar(meta){
  if(!meta || (!meta.posName && !meta.negName && !meta.posDescr && !meta.negDescr)){
    simListEl.innerHTML = "";
    return;
  }

  const html = `
    <div style="font-weight:700;margin-top:10px;margin-bottom:6px;text-align:center;text-decoration:underline;">Similar Figures</div>
    <div style="margin:0;color:#243447;line-height:1.5;">
      ${meta?.posName || meta?.posDescr ? `<strong>${escapeHtml(meta.posName||"")}</strong> — ${escapeHtml(meta.posDescr||"")}<br>` : ""}
      ${meta?.negName || meta?.negDescr ? `<strong>${escapeHtml(meta.negName||"")}</strong> — ${escapeHtml(meta.negDescr||"")}` : ""}
    </div>
  `;
  simListEl.innerHTML = html;
}
/* ================= Analysis Helper ===================== */
function renderAnalysis(text){
  if(!text){ 
    analysisPanel.hidden = true; 
    analysisBody.innerHTML = ""; 
    return; 
  }

  // Clean & space
  const dash = "[\\u2013-]"; 
  const normalized = String(text)
    .replace(/\r/g, '')
    .replace(/\\u003c/gi,"<")
    .replace(/\\u003e/gi,">")
    .replace(/([a-z0-9\)\.])n(?=[A-Z0-9(])/g, "$1\n\n")   // joiner -> two newlines
    .replace(/n(?=[\s\.\)])|n$/g, "")                     // trailing n
    .replace(/\n{3,}/g, "\n\n");

  // Build paragraphs/linebreaks
  let html = "<p>" + escapeHtml(normalized)
    .replace(/\n{2,}/g, "</p><p>")
    .replace(/\n/g, "<br>")
    + "</p>";

const rules = [
  // Bold any paragraph that starts with a number emoji (1️⃣ 2️⃣ 3️⃣ ...) and a title-like phrase
  /(<p>\s*\d+️⃣\s*)([^<:.]+?)(?=\s*[:—-])/gi,
];


  for (const rx of rules){
    html = html.replace(rx, (_m, pre, title) => pre ? `${pre}<strong>${title}</strong>` : `<strong>${title}</strong>`);
  }

  analysisBody.innerHTML = html;
  analysisPanel.hidden = false;
}


/* ================= helpers ===================== */
function setStatus(msg){ statusEl.textContent=msg||""; }
function disableButton(dis){ sendBtn.disabled=!!dis; }
function escapeHtml(s){ return String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }
function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

function showError(msg){
  errorBox.textContent = msg;
  errorBox.style.display = "block";
}
function hideError(){
  errorBox.textContent = "";
  errorBox.style.display = "none";
}

JSON.parseSafe = (t) => {
  try {
    return t ? JSON.parse(t) : {};
  } catch (e) {
    return { error: "Invalid JSON", raw: t };
  }
};


/* =================== AUTOCOMPLETE (Humans only) =================== */
const taWrap = document.getElementById('ta-wrap');
const taList = document.getElementById('ta-list');
let taTimer=null, taIndex=-1, taItems=[];

// Caches
const pagePropsCache = new Map();   // title -> { pageid, wikibase_item, description }
const humanCache     = new Map();   // QID -> boolean

inputEl.addEventListener('input', () => {
  clearTimeout(taTimer);
  const q = inputEl.value.trim();
  if (q.length < 2) { hideTA(); return; } // avoid noisy 1-char queries
  taTimer = setTimeout(() => loadSuggestionsHumanOnly(q), 250);
});

inputEl.addEventListener('keydown', (e) => {
  if (taWrap.style.display !== 'block') return;
  const max = taItems.length - 1;

  if (e.key === 'ArrowDown') {
    e.preventDefault();
    taIndex = Math.min(max, taIndex + 1);
    updateTAHighlight();
  } else if (e.key === 'ArrowUp') {
    e.preventDefault();
    taIndex = Math.max(0, taIndex - 1);
    updateTAHighlight();
  } else if (e.key === 'Enter') {
    if (taIndex >= 0) {
      e.preventDefault();
      chooseTA(taItems[taIndex].dataset.title);
    }
  } else if (e.key === 'Escape') {
    hideTA();
  }
});

// Hide on blur (tiny delay so clicks register)
inputEl.addEventListener('blur', () => setTimeout(hideTA, 120));

async function loadSuggestionsHumanOnly(q){
  try{
    // 1) Prefix search to get candidate titles
    const titles = await prefixSearch(q, 14); // a few extra before filtering
    if (!titles.length) { hideTA(); return; }

    // 2) Resolve titles -> wikibase_item + short description (batch)
    const withIds = await getWikibaseIds(titles);

    // 3) Check which IDs are humans via Wikidata P31=Q5 (batch)
    const ids = withIds.map(x => x.wikibase_item).filter(Boolean);
    const humanMap = await areHumans(ids); // Map(QID => true/false)

    // 4) Filter to humans and limit to 8
    const people = withIds
      .filter(x => x.wikibase_item && humanMap.get(x.wikibase_item))
      .slice(0, 8);

    if (!people.length) { hideTA(); return; }
    renderTA(people.map(p => ({ title: p.title, description: p.description || "" })));
  }catch(_){
    hideTA();
  }
}

/* Wikipedia: prefixsearch */
async function prefixSearch(q, limit=12){
  const url = new URL('https://en.wikipedia.org/w/api.php');
  url.search = new URLSearchParams({
    action:'query', list:'prefixsearch',
    pssearch:q, pslimit:String(limit),
    format:'json', origin:'*'
  });
  const res = await fetch(url, {
    headers: { 'User-Agent': 'CompassAutocomplete/1.0 (you@example.com)' }
  });
  const data = await res.json();
  return (data?.query?.prefixsearch || []).map(r => r.title);
}

/* Wikipedia: batch fetch pageprops (wikibase_item) + description */
async function getWikibaseIds(titles){
  const out = [];
  const unknown = [];

  titles.forEach(t => {
    if (pagePropsCache.has(t)) {
      out.push({ title: t, ...pagePropsCache.get(t) });
    } else {
      unknown.push(t);
    }
  });

  if (unknown.length) {
    const chunks = chunk(unknown, 40); // keep under URL limits
    for (const group of chunks) {
      const url = new URL('https://en.wikipedia.org/w/api.php');
      url.search = new URLSearchParams({
        action:'query',
        prop:'pageprops|description',
        redirects:'1',
        titles: group.join('|'),
        format:'json',
        origin:'*'
      });
      const res = await fetch(url);
      const data = await res.json();
      const pages = Object.values(data?.query?.pages || {});
      for (const p of pages) {
        const rec = {
          pageid: p.pageid,
          wikibase_item: p.pageprops?.wikibase_item || null,
          description: p.description || ""
        };
        const title = p.title; // normalized title
        pagePropsCache.set(title, rec);
        out.push({ title, ...rec });
      }
    }
  }
  const mapByTitle = new Map(out.map(o => [o.title, o]));
  return titles.map(t => mapByTitle.get(t)).filter(Boolean);
}

/* Wikidata: batch check P31 = Q5 (human) */
async function areHumans(ids){
  const result = new Map();
  const toFetch = [];

  ids.forEach(id => {
    if (humanCache.has(id)) {
      result.set(id, humanCache.get(id));
    } else if (!toFetch.includes(id)) {
      toFetch.push(id);
    }
  });

  if (toFetch.length) {
    const chunks = chunk(toFetch, 50);
    for (const group of chunks) {
      const url = new URL('https://www.wikidata.org/w/api.php');
      url.search = new URLSearchParams({
        action:'wbgetentities',
        ids: group.join('|'),
        props:'claims',
        format:'json',
        origin:'*'
      });
      const res = await fetch(url);
      const data = await res.json();
      const entities = data?.entities || {};
      for (const [qid, ent] of Object.entries(entities)) {
        let isHuman = false;
        const claims = ent?.claims?.P31 || [];
        for (const c of claims) {
          const id = c?.mainsnak?.datavalue?.value?.id;
          if (id === 'Q5') { isHuman = true; break; }
        }
        humanCache.set(qid, isHuman);
        result.set(qid, isHuman);
      }
    }
  }
  return result;
}

/* Render dropdown */
function renderTA(items){
  taList.innerHTML = items.map((r,i) => {
    const title = r.title;
    const desc  = r.description ? escapeHtml(r.description) : '';
    return `<div class="ta-item" role="option" data-index="${i}" data-title="${escapeHtml(title)}">
              <span class="ta-title">${escapeHtml(title)}</span>
              ${desc ? `<span class="ta-desc">${desc}</span>` : ''}
            </div>`;
  }).join('');

  taItems = Array.from(taList.querySelectorAll('.ta-item'));
  taItems.forEach(el => {
    el.addEventListener('mousedown', (ev) => {
      ev.preventDefault();
      chooseTA(ev.currentTarget.dataset.title);
    });
    el.addEventListener('mousemove', (ev) => {
      taIndex = Number(ev.currentTarget.dataset.index);
      updateTAHighlight();
    });
  });

  taIndex = -1;
  taWrap.style.display = 'block';
  updateTAHighlight();
}

function updateTAHighlight(){
  taItems.forEach((el, i) => {
    el.setAttribute('aria-selected', i === taIndex ? 'true' : 'false');
  });
}

function chooseTA(title){
  inputEl.value = title.replace(/^@/, '');
  hideTA();
  sendData();
}

function hideTA(){
  taWrap.style.display = 'none';
  taList.innerHTML = '';
  taItems = [];
  taIndex = -1;
}

function taIsOpen(){ return taWrap.style.display === 'block'; }
function chunk(arr, n){ const out=[]; for(let i=0;i<arr.length;i+=n) out.push(arr.slice(i,i+n)); return out; }
</script>



</body>
	<footer class="site-footer">
  <div class="footer-inner">
    <span>© 2025 WikiCompass</span>
    <span>Built by Auto Workforce</span>
  </div>
</footer>
</html>
