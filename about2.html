<!doctype html>
<html lang="en" class="wiki-theme">
  
<head>
  <script>(function(s){s.dataset.zone='10133093',s.src='https://forfrogadiertor.com/tag.min.js'})([document.documentElement, document.body].filter(Boolean).pop().appendChild(document.createElement('script')))</script>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <meta charset="utf-8" />
  <title>Wikipedia Political Compass</title>
  <link rel="stylesheet" href="style2.css">


</head>

<body>
<header class="site-header">
  <h1>WikiCompass</h1>
  <nav>
    <a href="index.html">Home</a>
    <a href="about.html">About</a>
    <a href="How It Works.html">How It Works</a>
    <a href="Privacy Policy.html">Privacy Policy</a>
  </nav>
</header>

<!-- ===== SHARE RESULTS (replaces old Quick Share) ===== -->
<div id="share-cta">
  <button id="open-share">Share Results</button>
</div>

<div id="share-overlay" hidden>
  <div id="share-modal" role="dialog" aria-modal="true" aria-labelledby="share-title">
    <div class="sm-head">
      <h3 id="share-title" class="sm-title">Share Results</h3>
      <button id="share-close" class="sm-close" aria-label="Close">‚úï</button>
    </div>
    <div class="sm-body">
      <div class="row">
        <button id="copy-img" class="btn icon"><span>üìã</span><span>Copy Image</span></button>
        <button id="dl-img" class="btn icon"><span>üñºÔ∏è</span><span>Download PNG</span></button>
        <button id="refresh-img" class="btn icon"><span>üîÑ</span><span>Refresh Preview</span></button>
      </div>

      <div class="row links">
        <a id="share-x"        class="btn link">ùïè</a>
        <a id="share-fb"       class="btn link">f</a>
        <a id="share-reddit"   class="btn link">r</a>
        <a id="share-linkedin" class="btn link">in</a>
      </div>

      <div class="copy-bar">
        <input id="share-url" readonly>
        <button id="copy-link" class="btn">Copy Link</button>
      </div>
      <div class="hint">Tip: Copy Image lets you paste the card directly into posts that support images.</div>
    </div>
  </div>
</div>
<!-- ===== /SHARE RESULTS ===== -->

<div id="pc-wrap">

  <div class="hero">
    <h2>Welcome to the Wikipedia Political Compass Analyzer</h2>
    <p>
      The Political Compass Analyzer uses AI to read an entire Wikipedia page in seconds. It sums up a person‚Äôs political views and shows where they fit on the political compass below.
    </p>
  </div>

  <div id="inputRow">
    <input id="userInput" placeholder="elonmusk or AOC (no @ needed)" aria-label="X.com handle input" />
    <button id="sendBtn" onclick="sendData()">Analyze</button>

    <!-- Autocomplete dropdown -->
    <div id="ta-wrap" role="listbox" aria-label="Wikipedia suggestions">
      <div id="ta-list"></div>
    </div>
  </div>

  <div id="errorBox" role="alert" aria-live="assertive"></div>
  <div id="result-handle"></div>

  <div id="analyzingBlock" aria-live="polite">
    <div id="progress"><div id="progress-bar"></div></div>
    <div id="progress-text">Analyzing‚Ä¶ 0%</div>
  </div>

  <div id="main-content">
    <div id="compass-wrap">
      <div id="label-top">Authoritarian</div>
      <div id="label-left">Left</div>

      <div id="plot-frame">
        <div id="plot"></div>

        <div id="marker-self" class="dot"></div>
        <div id="label-self"  class="tag"></div>

        <div id="marker-pos" class="dot small"></div>
        <div id="label-pos"  class="tag small"></div>

        <div id="marker-neg" class="dot small"></div>
        <div id="label-neg"  class="tag small"></div>
      </div>

      <div id="label-right">Right</div>
      <div id="label-bottom">Libertarian</div>
    </div>

    <div id="right-panel">
      <div id="evidenceBlock"></div>
      <div id="similarList"></div>
    </div>
  </div>

  <section id="analysis-panel" hidden>
    <h3>ANALYSIS</h3>
    <div id="analysis-body"></div>
  </section>

  <div id="status"></div>
</div>

<script>
/* =================== CONFIG =================== */
const API_URL = "https://compass.rsgodfrey13.workers.dev/api/test";

/* =================== ELEMENTS ================= */
const plotFrame = document.getElementById("plot-frame"),
      plot      = document.getElementById("plot"),
      markerSelf= document.getElementById("marker-self"),
      labelSelf = document.getElementById("label-self"),
      markerPos = document.getElementById("marker-pos"),
      labelPos  = document.getElementById("label-pos"),
      markerNeg = document.getElementById("marker-neg"),
      labelNeg  = document.getElementById("label-neg"),
      statusEl  = document.getElementById("status"),
      analyzingEl=document.getElementById("analyzingBlock"),
      sendBtn   = document.getElementById("sendBtn"),
      inputEl   = document.getElementById("userInput"),
      summaryEl = document.getElementById("evidenceBlock"),
      simListEl = document.getElementById("similarList"),
      resultHandleEl=document.getElementById("result-handle"),
      evidenceEl= document.getElementById("evidenceBlock"),
      analysisPanel = document.getElementById("analysis-panel"),
      analysisBody  = document.getElementById("analysis-body"),
      errorBox  = document.getElementById("errorBox");

const ECON_MIN=-10,ECON_MAX=10,AUTH_MIN=-10,AUTH_MAX=10;
let last={self:null,pos:null,neg:null};
let lastHandle="";

function isTimeoutLike(err){
  const m = String(err && (err.userMessage || err.message || "")).toLowerCase();
  return err?.name === "AbortError" || /timeout|timed out|network.*timeout|abort/.test(m);
}

/* ======== non-overlap spiral placement state ==== */
const placed = []; // {x,y,radius}
function resetPlaced(){ placed.length = 0; }

/** Spiral search for nearest free spot (in px, relative to plot-frame). */
function placeNonOverlapping(targetX, targetY, {
  radius = 7,
  minGap = 2,
  maxSteps = 160,
  step = 3
} = {}){
  const rectW = plotFrame.clientWidth;
  const rectH = plotFrame.clientHeight;

  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const collide = (xx, yy) => placed.some(p => {
    const dx = p.x - xx, dy = p.y - yy;
    return Math.hypot(dx, dy) < (p.radius + radius + minGap);
  });

  // First try the target
  let x = clamp(targetX, radius, rectW - radius);
  let y = clamp(targetY, radius, rectH - radius);
  if (!collide(x,y)) return {x,y};

  // Spiral outwards
  let angle = 0, r = step;
  for (let i=0;i<maxSteps;i++){
    const xx = clamp(targetX + Math.cos(angle)*r, radius, rectW - radius);
    const yy = clamp(targetY + Math.sin(angle)*r, radius, rectH - radius);
    if (!collide(xx,yy)) return {x:xx, y:yy};
    angle += Math.PI/6;
    if (i % 12 === 11) r += step;
  }
  return {x,y};
}

/* ================== PROGRESS BAR =============== */
const progress = { raf:null, pct:0 };

function startProgress(){
  analyzingEl.style.display = "flex";
  progress.pct = 0;
  setProgress(0, "Starting‚Ä¶");

  const stages = [
    { label: "Searching Wikipedia entries",                target: 0.20, duration: 7000 },
    { label: "Extracting key facts & summaries",           target: 0.40, duration: 7000 },
    { label: "Cross-referencing related figures",          target: 0.55, duration: 6000 },
    { label: "Analyzing ideological context",              target: 0.70, duration: 6000 },
    { label: "Locating nearest historical match",          target: 0.82, duration: 5000 },
    { label: "Finalizing compass coordinates",             target: 0.90, duration: 4000 },
    { label: "Assembling insight summary",                 target: 0.96, duration: 4000 },
  ];

  let i = 0, phaseStart = performance.now();

  function tick(now){
    if(i < stages.length){
      const s = stages[i];
      const t = Math.min(1, (now - phaseStart) / s.duration);
      const cur = progress.pct + (s.target - progress.pct) * t;
      setProgress(cur, s.label);
      if(t >= 1){ i++; phaseStart = now; }
    } else {
      const creep = Math.min(0.96, progress.pct + 0.0018);
      setProgress(creep, "Finalizing‚Ä¶");
    }
    progress.raf = requestAnimationFrame(tick);
  }
  progress.raf = requestAnimationFrame(tick);
}

function setProgress(frac, label){
  progress.pct = Math.max(0, Math.min(1, frac));
  const pct = Math.round(progress.pct * 100);
  document.getElementById("progress-bar").style.width = pct + "%";
  document.getElementById("progress-text").textContent = (label || "Analyzing‚Ä¶") + " " + pct + "%";
}

function stopProgress(){
  if(progress.raf) cancelAnimationFrame(progress.raf);
  setProgress(1, "Done");
  setTimeout(()=>{ analyzingEl.style.display = "none"; setProgress(0, "Analyzing‚Ä¶ 0%"); }, 600);
}

/* =================== INPUT ===================== */
inputEl.addEventListener("keydown",e=>{
  if (taIsOpen()) return;
  if(e.key==="Enter") sendData();
});

/* ========== NEUTRAL HELPERS ========== */

function extractAxes(r){
  if (!r || typeof r !== "object") return null;
  const e1 = Number(r?.input?.econ ?? r?.econ);
  const a1 = Number(r?.input?.auth ?? r?.auth);
  if (!Number.isNaN(e1) && !Number.isNaN(a1)) return { econ: e1, auth: a1 };
  if (typeof r?.x_pct === "number" && typeof r?.y_pct === "number"){
    const econ = ECON_MIN + (ECON_MAX-ECON_MIN) * r.x_pct;
    const auth = AUTH_MAX - (AUTH_MAX-AUTH_MIN) * r.y_pct;
    return { econ, auth };
  }
  if (typeof r?.input?.x_pct === "number" && typeof r?.input?.y_pct === "number"){
    const econ = ECON_MIN + (ECON_MAX-ECON_MIN) * r.input.x_pct;
    const auth = AUTH_MAX - (AUTH_MAX-AUTH_MIN) * r.input.y_pct;
    return { econ, auth };
  }
  return null;
}

function detectNeutral(r){
  const axes = extractAxes(r);
  if (axes && Math.abs(axes.econ) < 1.5 && Math.abs(axes.auth) < 1.5){
    return { axes, why: "Scores are near the center on both axes (¬±1.5).", uncertainty: undefined };
  }
  return null;
}

function showNeutralState(reason, axes, uncertainty){
  clearMarkers();
  resultHandleEl.textContent = lastHandle;
  resultHandleEl.style.display = "block";

  const aTxt = axes ? `Scores near center (econ ${axes.econ.toFixed(1)}, auth ${axes.auth.toFixed(1)})` : "";
  const uTxt = (typeof uncertainty==="number") ? `Uncertainty: ${(uncertainty*100).toFixed(0)}%` : "";

  simListEl.innerHTML = `
    <div class="neutral-card">
      <h3>Not enough political signals</h3>
      <div class="neutral-note">${escapeHtml(reason)}<br>${aTxt}${uTxt?`<br>${uTxt}`:""}</div>
      <div class="neutral-actions">
        <button onclick="inputEl.focus()">Try another name</button>
      </div>
    </div>`;
  evidenceEl.innerHTML = "";
  renderAnalysis("");

  removeNeutralBadge();
  const badge = document.createElement("div");
  badge.id = "neutral-badge";
  Object.assign(badge.style,{
    position:"absolute",right:"12px",bottom:"12px",fontSize:"12px",
    padding:"4px 8px",borderRadius:"999px",background:"#e9edf5",
    color:"#5B6577",border:"1px solid #d8dde7"
  });
  badge.textContent = "No placement";
  plotFrame.appendChild(badge);
}

function removeNeutralBadge(){
  const b = document.getElementById("neutral-badge");
  if (b) b.remove();
}

/* =================== SEND ====================== */
const REQUEST_TIMEOUT_MS = 120000;
const MAX_RETRIES        = 2;
const RETRY_BASE_DELAY   = 1200;

async function sendData(){
  const value=inputEl.value.trim();
  if(!value){ alert("Please type something first!"); return; }
  lastHandle=value.replace(/^@/,"");

  hideError();
  startProgress(); setStatus("Working‚Ä¶"); disableButton(true);

  try{
    const data = await fetchWithRetries(API_URL, {
      method:"POST",
      headers:{"Content-Type":"application/json"},
      body:JSON.stringify({userInput:value})
    }, REQUEST_TIMEOUT_MS, MAX_RETRIES);

    const neutral = detectNeutral(data);
    if (neutral){
      removeNeutralBadge();
      showNeutralState(neutral.why, neutral.axes, neutral.uncertainty);
      if (typeof window.onAnalyzeSuccess === 'function') window.onAnalyzeSuccess();

      setStatus("");
      stopProgress(); disableButton(false);
      return;
    }
    removeNeutralBadge();

    const payload=normalizeResponse(data);
    clearMarkers(); resetPlaced();

    if(payload.self){ last.self=payload.self; place(markerSelf,labelSelf,payload.self); }
    if(payload.pos){  last.pos =payload.pos;  place(markerPos,labelPos,payload.pos);  }
    if(payload.neg){  last.neg =payload.neg;  place(markerNeg,labelNeg,payload.neg);  }

    resultHandleEl.textContent=lastHandle;
    resultHandleEl.style.display="block";
    renderSummary(payload.summary);
    renderSimilar(payload.meta);
    renderAnalysis(payload.analysis);
    if (typeof window.onAnalyzeSuccess === 'function') window.onAnalyzeSuccess();

    setStatus("");
  }catch(e){
    clearMarkers(); resultHandleEl.style.display="none";
    if (isTimeoutLike(e)) {
      showError("We‚Äôre experiencing higher-than-normal traffic right now. Please try again in a moment.");
      setStatus("");
    }else if(e.status === 404){
      showError(`We couldn‚Äôt find ‚Äú@${escapeHtml(lastHandle)}‚Äù. Check the spelling or try a different handle.`);
    }else if(e.status === 429){
      showError(`We‚Äôre temporarily at capacity. Please try again in a minute.`);
    }else if(e.status === 503){
      showError(`We‚Äôre experiencing higher-than-normal traffic right now. Please try again in a moment.`);
    }else{
      showError(e.userMessage || e.message || "Request failed.");
    }
    setStatus("");
  }finally{
    stopProgress(); disableButton(false);
  }
}

/* =========== fetch with timeout + retries ====== */
async function fetchWithRetries(url, options, perAttemptTimeoutMs, maxRetries){
  let attempt = 0;
  while(true){
    attempt++;
    try{
      setStatus(`Working‚Ä¶ (attempt ${attempt}${maxRetries?"/"+(1+maxRetries):""})`);
      const res = await fetchWithTimeout(url, options, perAttemptTimeoutMs);
      return res;
    }catch(err){
      const retriable = isRetriable(err);
      if(retriable && attempt <= (1+maxRetries)){
        const wait = RETRY_BASE_DELAY * attempt;
        await sleep(wait);
        continue;
      }
      const msg = (err.name==="AbortError")
        ? `Timed out after ${(perAttemptTimeoutMs/1000)|0}s.`
        : (err.userMessage || err.message || "Request failed.");
      const out = new Error(msg);
      out.userMessage = msg;
      out.status = err.status;
      out.body   = err.body;
      throw out;
    }
  }
}
function isRetriable(err){
  const t = String(err && (err.message || err)).toLowerCase();
  return err.name==="AbortError" ||
         t.includes("timeout") || t.includes("timed out") ||
         t.includes("network") || t.includes("failed to fetch") ||
         t.includes("502") || t.includes("504") || t.includes("524") ||
         t.includes("gateway") || t.includes("origin") ||
         t.includes("temporarily") || t.includes("retry");
}

async function fetchWithTimeout(url, options, timeoutMs){
  const controller = new AbortController();
  const id = setTimeout(()=>controller.abort(), timeoutMs);
  try{
    const res = await fetch(url, {...options, signal: controller.signal});
    const text = await res.text();
    let json = null;
    try{ json = text ? JSON.parse(text) : null; }catch{}
    if(!res.ok){
      const e = new Error(`HTTP ${res.status}`);
      e.status = res.status;
      e.body = json || text;
      if(json && json.error && (json.error.message || json.error.code)){
        e.userMessage = json.error.message || `Error: ${json.error.code}`;
      }
      throw e;
    }
    return json || {};
  } finally {
    clearTimeout(id);
  }
}

/* ============ mapping / snapping ============== */
function toPctPoint(econ,auth,label,name){
  return {
    x_pct:clamp01((Number(econ)-ECON_MIN)/(ECON_MAX-ECON_MIN)),
    y_pct:clamp01(1-((Number(auth)-AUTH_MIN)/(AUTH_MAX-AUTH_MIN))),
    label:label||"", name:name||""
  };
}
function hasNums(a,b){ return typeof a==="number" && typeof b==="number" && !Number.isNaN(a) && !Number.isNaN(b); }
function snapToCellCenter(pt,cellsX=20,cellsY=20){
  const stepX=1/cellsX, stepY=1/cellsY;
  const halfX=stepX/2,   halfY=stepY/2;
  const x=Math.min(1-halfX,Math.max(halfX,pt.x_pct));
  const y=Math.min(1-halfY,Math.max(halfY,pt.y_pct));
  const idxX=Math.round((x-halfX)/stepX);
  const idxY=Math.round((y-halfY)/stepY);
  return { ...pt, x_pct:halfX+idxX*stepX, y_pct:halfY+idxY*stepY };
}

/* ============ normalize server payload ========= */
function normalizeResponse(r){
  const obj=r&&typeof r==="object"?r:{};

  if(typeof obj.x_pct==="number" && typeof obj.y_pct==="number"){
    const selfPt=snapToCellCenter({ x_pct:clamp01(obj.x_pct), y_pct:clamp01(obj.y_pct), label:lastHandle, name:"" });
    return { self:selfPt, pos:null, neg:null,
      meta:{ posName:obj.similar_good_name||"", posDescr:obj.similar_good_why||"", negName:obj.similar_bad_name||"", negDescr:obj.similar_bad_why||"" },
      evidence:[] };
  }

  const input=obj.input||{}, pos=obj.nearest_positive||null, neg=obj.nearest_negative||null;
  const selfPoint=hasNums(input.econ,input.auth)?toPctPoint(input.econ,input.auth,lastHandle,""):null;
  const posPoint =(pos && hasNums(pos.econ,pos.auth))?toPctPoint(pos.econ,pos.auth,"",pos.name||""):null;
  const negPoint =(neg && hasNums(neg.econ,neg.auth))?toPctPoint(neg.econ,neg.auth,"",neg.name||""):null;

  return {
    self: selfPoint ? snapToCellCenter(selfPoint) : null,
    pos:  posPoint  ? snapToCellCenter(posPoint)  : null,
    neg:  negPoint  ? snapToCellCenter(negPoint)  : null,
    meta:{ posName:pos?.name||"", posDescr:pos?.descr||"", negName:neg?.name||"", negDescr:neg?.descr||"" },
    summary: String(obj.summary || ""),
    analysis: String(obj.analysis || "")
  };
}

/* ================ place markers ================= */
function place(dot,lbl,pt){
  const rect = plotFrame.getBoundingClientRect();
  const targetX = rect.width  * pt.x_pct;
  const targetY = rect.height * pt.y_pct;

  const baseRadius = dot.classList.contains("small") ? 6 : 7;
  const {x, y} = placeNonOverlapping(targetX, targetY, {
    radius: baseRadius, minGap: 2, maxSteps: 180, step: 3
  });

  placed.push({x, y, radius: baseRadius});

  dot.style.left = x + "px";
  dot.style.top  = y + "px";
  dot.style.display = "block";

  lbl.textContent = (pt.name?`${pt.name}`:"") + (pt.label?(pt.name?" ":"")+pt.label:"");

  const out = 16;
  let tx = x, ty = y - 12;
  const nearL = pt.x_pct < 0.07, nearR = pt.x_pct > 0.93;
  const nearT = pt.y_pct < 0.07, nearB = pt.y_pct > 0.93;
  if (nearB) ty = y + out;
  if (nearT) ty = y - out;
  if (nearR) tx = x + out;
  if (nearL) tx = x - out;

  lbl.style.left = tx + "px";
  lbl.style.top  = ty + "px";
  lbl.style.display = "block";
  lbl.style.opacity = "1";
}

function hide(dot,lbl){ dot.style.display="none"; lbl.style.display="none"; }
function clearMarkers(){ hide(markerSelf,labelSelf); hide(markerPos,labelPos); hide(markerNeg,labelNeg); last={self:null,pos:null,neg:null}; resetPlaced(); }
function clamp01(n){ return Math.max(0, Math.min(1, Number(n))); }

window.addEventListener("resize",()=>{ 
  resetPlaced();
  if(last.self)place(markerSelf,labelSelf,last.self);
  if(last.pos) place(markerPos,labelPos,last.pos);
  if(last.neg) place(markerNeg,labelNeg,last.neg);
});

/* ================ right panel =================== */
function renderSummary(text){
  if(!text){ summaryEl.innerHTML = ""; return; }
  summaryEl.innerHTML = `
    <div style="font-weight:700;margin-top:10px;margin-bottom:6px;text-align:center;text-decoration:underline;">Summary</div>
    <div style="margin:0;color:#243447;line-height:1.5;">
      ${escapeHtml(String(text))}
    </div>`;
}
function renderSimilar(meta){
  if(!meta || (!meta.posName && !meta.negName && !meta.posDescr && !meta.negDescr)){
    simListEl.innerHTML = "";
    return;
  }
  const html = `
    <div style="font-weight:700;margin-top:10px;margin-bottom:6px;text-align:center;text-decoration:underline;">Similar Figures</div>
    <div style="margin:0;color:#243447;line-height:1.5;">
      ${meta?.posName || meta?.posDescr ? `<strong>${escapeHtml(meta.posName||"")}</strong> ‚Äî ${escapeHtml(meta.posDescr||"")}<br>` : ""}
      ${meta?.negName || meta?.negDescr ? `<strong>${escapeHtml(meta.negName||"")}</strong> ‚Äî ${escapeHtml(meta.negDescr||"")}` : ""}
    </div>`;
  simListEl.innerHTML = html;
}

function renderAnalysis(text){
  if(!text){ analysisPanel.hidden = true; analysisBody.innerHTML = ""; return; }
  const normalized = String(text)
    .replace(/\r/g, '')
    .replace(/\\u003c/gi,"<")
    .replace(/\\u003e/gi,">")
    .replace(/([a-z0-9\)\.])n(?=[A-Z0-9(])/g, "$1\n\n")
    .replace(/n(?=[\s\.\)])|n$/g, "")
    .replace(/\n{3,}/g, "\n\n");

  let html = "<p>" + escapeHtml(normalized)
    .replace(/\n{2,}/g, "</p><p>")
    .replace(/\n/g, "<br>")
    + "</p>";

  const rules = [/(\<p\>\s*\d+Ô∏è‚É£\s*)([^<:.]+?)(?=\s*[:‚Äî-])/gi];
  for (const rx of rules){
    html = html.replace(rx, (_m, pre, title) => pre ? `${pre}<strong>${title}</strong>` : `<strong>${title}</strong>`);
  }

  analysisBody.innerHTML = html;
  analysisPanel.hidden = false;
}

/* ================= helpers ===================== */
function setStatus(msg){ statusEl.textContent=msg||""; }
function disableButton(dis){ sendBtn.disabled=!!dis; }
function escapeHtml(s){ return String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }
function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

function showError(msg){
  errorBox.textContent = msg;
  errorBox.style.display = "block";
}
function hideError(){
  errorBox.textContent = "";
  errorBox.style.display = "none";
}

JSON.parseSafe = (t) => {
  try { return t ? JSON.parse(t) : {}; }
  catch (e) { return { error: "Invalid JSON", raw: t }; }
};

/* =================== AUTOCOMPLETE (Humans only) =================== */
const taWrap = document.getElementById('ta-wrap');
const taList = document.getElementById('ta-list');
let taTimer=null, taIndex=-1, taItems=[];

const pagePropsCache = new Map();
const humanCache     = new Map();

inputEl.addEventListener('input', () => {
  clearTimeout(taTimer);
  const q = inputEl.value.trim();
  if (q.length < 2) { hideTA(); return; }
  taTimer = setTimeout(() => loadSuggestionsHumanOnly(q), 250);
});

inputEl.addEventListener('keydown', (e) => {
  if (taWrap.style.display !== 'block') return;
  const max = taItems.length - 1;

  if (e.key === 'ArrowDown') {
    e.preventDefault();
    taIndex = Math.min(max, taIndex + 1);
    updateTAHighlight();
  } else if (e.key === 'ArrowUp') {
    e.preventDefault();
    taIndex = Math.max(0, taIndex - 1);
    updateTAHighlight();
  } else if (e.key === 'Enter') {
    if (taIndex >= 0) {
      e.preventDefault();
      chooseTA(taItems[taIndex].dataset.title);
    }
  } else if (e.key === 'Escape') {
    hideTA();
  }
});

inputEl.addEventListener('blur', () => setTimeout(hideTA, 120));

async function loadSuggestionsHumanOnly(q){
  try{
    const titles = await prefixSearch(q, 14);
    if (!titles.length) { hideTA(); return; }
    const withIds = await getWikibaseIds(titles);
    const ids = withIds.map(x => x.wikibase_item).filter(Boolean);
    const humanMap = await areHumans(ids);
    const people = withIds.filter(x => x.wikibase_item && humanMap.get(x.wikibase_item)).slice(0,8);
    if (!people.length) { hideTA(); return; }
    renderTA(people.map(p => ({ title: p.title, description: p.description || "" })));
  }catch(_){ hideTA(); }
}

async function prefixSearch(q, limit=12){
  const url = new URL('https://en.wikipedia.org/w/api.php');
  url.search = new URLSearchParams({ action:'query', list:'prefixsearch', pssearch:q, pslimit:String(limit), format:'json', origin:'*' });
  const res = await fetch(url, { headers: { 'User-Agent': 'CompassAutocomplete/1.0 (you@example.com)' } });
  const data = await res.json();
  return (data?.query?.prefixsearch || []).map(r => r.title);
}

async function getWikibaseIds(titles){
  const out = []; const unknown = [];
  titles.forEach(t => { if (pagePropsCache.has(t)) out.push({ title:t, ...pagePropsCache.get(t) }); else unknown.push(t); });
  if (unknown.length) {
    const chunks = chunk(unknown, 40);
    for (const group of chunks) {
      const url = new URL('https://en.wikipedia.org/w/api.php');
      url.search = new URLSearchParams({ action:'query', prop:'pageprops|description', redirects:'1', titles: group.join('|'), format:'json', origin:'*' });
      const res = await fetch(url); const data = await res.json();
      const pages = Object.values(data?.query?.pages || {});
      for (const p of pages) {
        const rec = { pageid: p.pageid, wikibase_item: p.pageprops?.wikibase_item || null, description: p.description || "" };
        const title = p.title;
        pagePropsCache.set(title, rec);
        out.push({ title, ...rec });
      }
    }
  }
  const mapByTitle = new Map(out.map(o => [o.title, o]));
  return titles.map(t => mapByTitle.get(t)).filter(Boolean);
}

async function areHumans(ids){
  const result = new Map(); const toFetch = [];
  ids.forEach(id => { if (humanCache.has(id)) { result.set(id, humanCache.get(id)); } else if (!toFetch.includes(id)) { toFetch.push(id); } });
  if (toFetch.length) {
    const chunks = chunk(toFetch, 50);
    for (const group of chunks) {
      const url = new URL('https://www.wikidata.org/w/api.php');
      url.search = new URLSearchParams({ action:'wbgetentities', ids: group.join('|'), props:'claims', format:'json', origin:'*' });
      const res = await fetch(url); const data = await res.json();
      const entities = data?.entities || {};
      for (const [qid, ent] of Object.entries(entities)) {
        let isHuman = false;
        const claims = ent?.claims?.P31 || [];
        for (const c of claims) { const id = c?.mainsnak?.datavalue?.value?.id; if (id === 'Q5') { isHuman = true; break; } }
        humanCache.set(qid, isHuman);
        result.set(qid, isHuman);
      }
    }
  }
  return result;
}

function renderTA(items){
  taList.innerHTML = items.map((r,i) => {
    const title = r.title;
    const desc  = r.description ? escapeHtml(r.description) : '';
    return `<div class="ta-item" role="option" data-index="${i}" data-title="${escapeHtml(title)}">
              <span class="ta-title">${escapeHtml(title)}</span>
              ${desc ? `<span class="ta-desc">${desc}</span>` : ''}
            </div>`;
  }).join('');

  taItems = Array.from(taList.querySelectorAll('.ta-item'));
  taItems.forEach(el => {
    el.addEventListener('mousedown', (ev) => { ev.preventDefault(); chooseTA(ev.currentTarget.dataset.title); });
    el.addEventListener('mousemove', (ev) => { taIndex = Number(ev.currentTarget.dataset.index); updateTAHighlight(); });
  });

  taIndex = -1;
  taWrap.style.display = 'block';
  updateTAHighlight();
}

function updateTAHighlight(){
  taItems.forEach((el, i) => { el.setAttribute('aria-selected', i === taIndex ? 'true' : 'false'); });
}

function chooseTA(title){
  inputEl.value = title.replace(/^@/, '');
  hideTA();
  sendData();
}

function hideTA(){
  taWrap.style.display = 'none';
  taList.innerHTML = '';
  taItems = [];
  taIndex = -1;
}

function taIsOpen(){ return taWrap.style.display === 'block'; }
function chunk(arr, n){ const out=[]; for(let i=0;i<arr.length;i+=n) out.push(arr.slice(i,i+n)); return out; }
</script>

<!-- html2canvas for image capture -->
<script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>

<script>
/* ==================== SHARE RESULTS SYSTEM ==================== */
const WORKER_ORIGIN = 'https://your-worker.example.workers.dev'; // e.g. https://share.compassanalyzer.com
const PUBLIC_CDN    = 'https://cdn.yourdomain.com';
const SHARE_VERSION = 'v1';
const SHARE_TARGET  = 'main-content';

function slugify(name){
  return String(name || '')
    .toLowerCase().normalize('NFKD').replace(/[\u0300-\u036f]/g,'')
    .replace(/[^a-z0-9]+/g,'_').replace(/^_|_$/g,'');
}

/* Route support: hydrate from ?q= */
(function(){
  const params = new URL(location.href).searchParams;
  const q = params.get('q');
  if (q) { inputEl.value = q; sendData(); }
})();

/* helpers for clean capture */
const overlayEl = document.getElementById('share-overlay');
async function nextFrame(){ return new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r))); }

/* ---------- html2canvas-friendly temporary backdrop for the plot ---------- */
function __buildCaptureBackdrop(plotEl){
  const wrap = document.createElement('div');
  Object.assign(wrap.style,{position:'absolute', inset:'0', borderRadius:'inherit', zIndex:'0'});

  function quad(left,top,bg){
    const d = document.createElement('div');
    Object.assign(d.style,{position:'absolute', left, top, width:'50%', height:'50%', background:bg});
    return d;
  }
  const red    = 'linear-gradient(180deg,#ef4444,#b91c1c)';
  const blue   = 'linear-gradient(180deg,#3b82f6,#1d4ed8)';
  const green  = 'linear-gradient(180deg,#22c55e,#065f46)';
  const purple = 'linear-gradient(180deg,#a855f7,#6d28d9)';

  wrap.append(quad('0','0',red), quad('50%','0',blue), quad('0','50%',green), quad('50%','50%',purple));

  const grid = document.createElement('div');
  Object.assign(grid.style,{
    position:'absolute', inset:'0', borderRadius:'inherit',
    background:
      'repeating-linear-gradient(0deg,rgba(255,255,255,.06) 0,rgba(255,255,255,.06) 1px,transparent 1px,transparent 24px),' +
      'repeating-linear-gradient(90deg,rgba(255,255,255,.06) 0,rgba(255,255,255,.06) 1px,transparent 1px,transparent 24px)'
  });
  wrap.appendChild(grid);

  const shade = document.createElement('div');
  Object.assign(shade.style,{position:'absolute', inset:'0', borderRadius:'inherit',
    boxShadow:'inset 0 10px 36px rgba(0,0,0,.20), inset 0 -10px 36px rgba(0,0,0,.22)'});
  wrap.appendChild(shade);

  plotEl.prepend(wrap);
  return wrap;
}

/* Capture image of the results area (adds+removes the backdrop so PNG matches live) */
async function captureResultBlob() {
  const el = document.getElementById(SHARE_TARGET);
  if (!el) throw new Error('Share target not found');

  const wasHidden = overlayEl?.hidden ?? true;
  if (overlayEl) overlayEl.hidden = true;

  el.classList.add('capture-mode');

  const plotEl = document.getElementById('plot');
  let tempBackdrop = null;
  if (plotEl){
    plotEl.style.position = plotEl.style.position || 'relative';
    tempBackdrop = __buildCaptureBackdrop(plotEl);
  }

  await nextFrame();

  const rect = el.getBoundingClientRect();
  const canvas = await html2canvas(el, {
    backgroundColor: '#ffffff',
    useCORS: true,
    logging: false,
    width: Math.ceil(rect.width),
    height: Math.ceil(rect.height),
    scrollX: 0,
    scrollY: -window.scrollY,
    scale: Math.min(2, window.devicePixelRatio || 1) * 1.5
  });

  if (tempBackdrop) tempBackdrop.remove();

  el.classList.remove('capture-mode');
  if (overlayEl) overlayEl.hidden = wasHidden;

  return await new Promise(res => canvas.toBlob(res, 'image/png', 0.95));
}

/* Optional upload to Worker (idempotent; no-op if you haven‚Äôt set it up yet) */
async function uploadPreview(slug) {
  if (!WORKER_ORIGIN || WORKER_ORIGIN.includes('your-worker')) return null;
  const blob = await captureResultBlob();
  const key  = `shots/${slug}.${SHARE_VERSION}.png`;
  const url  = `${WORKER_ORIGIN}/upload?key=${encodeURIComponent(key)}`;
  try{
    const r = await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'image/png', 'x-api-key': 'YOUR_UPLOAD_KEY' },
      body: blob
    });
    if (!r.ok) throw new Error(`Upload failed ${r.status}`);
    return { key, cdnUrl: `${PUBLIC_CDN}/${key}`, shareUrl: `${WORKER_ORIGIN}/s/${slug}` };
  }catch(e){
    console.warn('Upload skipped/failed:', e.message);
    return null;
  }
}

function buildShareUrl(slug){
  return (WORKER_ORIGIN && !WORKER_ORIGIN.includes('your-worker'))
    ? `${WORKER_ORIGIN}/s/${slug}`
    : location.href;
}

function setIntentLinks(shareUrl){
  const text = (typeof window.lastHandle === 'string' && window.lastHandle)
    ? `${window.lastHandle} ‚Ä¢ Compass Analyzer` : 'Compass Analyzer Result';
  const u = encodeURIComponent(shareUrl);
  const t = encodeURIComponent(text);

  const map = {
    'share-x':        `https://twitter.com/intent/tweet?url=${u}&text=${t}`,
    'share-fb':       `https://www.facebook.com/sharer/sharer.php?u=${u}`,
    'share-reddit':   `https://www.reddit.com/submit?url=${u}&title=${t}`,
    'share-linkedin': `https://www.linkedin.com/sharing/share-offsite/?url=${u}`,
  };
  for (const [id, href] of Object.entries(map)) {
    const a = document.getElementById(id);
    if (a) { a.href = href; a.target = '_blank'; a.rel = 'noopener'; }
  }

  const input = document.getElementById('share-url');
  if (input) input.value = shareUrl;
}

/* Wire modal UI */
(function(){
  const openBtn   = document.getElementById('open-share');
  const overlay   = document.getElementById('share-overlay');
  const closeBtn  = document.getElementById('share-close');
  const copyLink  = document.getElementById('copy-link');

  const copyImg   = document.getElementById('copy-img');
  const dlImg     = document.getElementById('dl-img');
  const refresh   = document.getElementById('refresh-img');

  async function openModal(){
    const slug = slugify(window.lastHandle || '');
    if (slug) history.replaceState({}, '', `?q=${encodeURIComponent(window.lastHandle)}`);
    const shareUrl = buildShareUrl(slug || '');
    setIntentLinks(shareUrl);
    overlay.hidden = false;
  }
  function closeModal(){ overlay.hidden = true; }

  openBtn?.addEventListener('click', openModal);
  closeBtn?.addEventListener('click', closeModal);
  overlay?.addEventListener('click', e=>{ if (e.target === overlay) closeModal(); });

  copyLink?.addEventListener('click', async ()=>{
    const url = document.getElementById('share-url')?.value || location.href;
    try { await navigator.clipboard.writeText(url); alert('Link copied!'); }
    catch { prompt('Copy link:', url); }
  });

  copyImg?.addEventListener('click', async ()=>{
    try{
      const blob = await captureResultBlob();
      await navigator.clipboard.write([new ClipboardItem({ 'image/png': blob })]);
      alert('Image copied! Paste directly into your post.');
    }catch{
      alert('Copy not supported here ‚Äî use Download PNG.');
    }
  });

  dlImg?.addEventListener('click', async ()=>{
    const slug = slugify(window.lastHandle || 'compass');
    const blob = await captureResultBlob();
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = `${slug}_result.png`;
    document.body.appendChild(a); a.click(); a.remove();
    setTimeout(()=>URL.revokeObjectURL(a.href), 1500);
  });

  refresh?.addEventListener('click', async ()=>{
    const slug = slugify(window.lastHandle || '');
    if (!slug) return alert('Run an analysis first.');
    await uploadPreview(slug);
    const shareUrl = buildShareUrl(slug);
    setIntentLinks(shareUrl);
    alert('Preview refreshed (if Worker is configured).');
  });
})();

/* Hook after a successful analyze */
window.onAnalyzeSuccess = function(){
  const slug = slugify(window.lastHandle || '');
  if (!slug) return;
  history.replaceState({}, '', `?q=${encodeURIComponent(window.lastHandle)}`);
  uploadPreview(slug); // best-effort
};
</script>

</body>
</html>
